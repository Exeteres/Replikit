# Хранилище

Инструменты для работы с базой данных предоставлются пакетом `@replikit/storage`.

В Replikit в качестве основной базы данных используется `MongoDB`.
Любые другие БД, например реляционные, не поддерживаются.
Вы всегда можете использовать внешние источники данных в своем приложении, включая базы данных.
Однако для функционирования некоторых систем Replikit, например, системы контроля доступа, подойдет только `MongoDB`.

## Сущности и репозитории

Для работы с базой данных рекомендуется использовать сущности.
Сущности - это экземпляры классов, наследующих `Entity`.
Репозитории - это источники сущностей.

```ts
// connection - объект, контролирующий основное соединение с БД
// Оно будет установлено автоматически после запуска ядра
import { connection } from "@replikit/storage";

interface OrderItem {
    productId: number;
    count: number;
}

// Заказ, содержащий некоторое количество элементов в качестве примера сущности
class Order extends Entity {
    userId: number;
    items: OrderItem[];
}

// Регистрируем репозиторий, указывая имя коллекции
connection.registerRepistory("orders", Order);

/// ...

// Получаем репозиторий с заказами
const orders = connection.getRepository(Order);

// Создаем заказ и сохраняем
const order = orders.create({ userId: 1, items: [] });
await order.save();

// Получаем заказ по идентификатору
const stored = await orders.findOne({ _id: order._id })

// Удаляем
await stored.delete();
```

## Методы сущностей

Поскольку сущность - это экзепляр полноценного класса, вы можете объявлять и использовать методы:

```ts
import { User, CacheResult } from "@replikit/storage";

class Order extends Entity {
    userId: number;
    items: OrderItem[];

    @CacheResult
    async getUser(): Promise<User> {
        // Внутри каждого экземляра есть доступ к репозиторию - источнику
        // У репозитория есть ссылка на объект с соединением,
        // поэтому вы можете получить репозиторий другой сущности
        const repo = this.repository.connection.getRepository(User);
        const user = await repo.findOne({ _id: this.userId });
        return user!;
    }
}
```

Задача кода выше - организовать ленивую загрузку связанного пользователя.
В таком случае имеет смысл использовать декоратор `CacheResult`, чтобы закешировать результат вызова метода.

## Встроенные сущности

Вместе с хранилищем также предоставляются некоторые встроенные сущности и методы для их получения, доступные внутри контекста маршрутизатора.

| Сущность  | Метод        | Контекст         |
| --------- | ------------ | ---------------- |
| `Channel` | `getChannel` | `ChannelContext` |
| `User`    | `getUser`    | `AccountContext` |
| `Member`  | `getMember`  | `AccountContext` |

## Прямой доступ

Иногда необходимо взаимодействовать с MongoDB напрямую, без создания сущностей.
Текущая концепция никак не препятствует прямому доступу к коллекциям MongoDB, а, наоборот,
предоставляет все необходимые инструменты для его организации:

```ts
// Вы можете получить коллекцию, которая используется репозиторием
const collection = repository.collection;

// Или получить доступ к произвольной коллекции,
// для которой не зарегистрирован репозиторий
const collection = connection.getRawCollection<Item>("items");

// Вы можете преобразовать документ, полученный из коллекции, к сущности
const entity = repository.createEntity(document);

// И наоборот, сущность к документу, который можно сохранить в коллекцию
const document = repository.createDocument(entity);
```

Хорошим примером является пакет `@replikit/attachments`, использующий прямой доступ для
пакетного обновления данных.
